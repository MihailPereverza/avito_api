## Микросервис для работы с балансом пользователей

Настройка виртуального окружения:
1. APP_PORT - порт, на котором будет запущено приложение (8080 по умолчанию)
2. DB_PORT - порт, на котором будет запущена база данных
3. DB_USER - имя пользователя базы данных
4. DB_PASS - пароль от базы данных
5. DB_NAME - название стартовой базы данных
6. DB_HOST - хост, на котором запущена база (postgres, если приложение будет также в контейнере с базой)


Запуск проекта в докере:
1. Настроить .env файл: DP_HOST установить postgres
2. Установить swaggo `go get github.com/swaggo/swag/cmd/swag`
3. Выполнить `swag init -g ./cmd/http/main.go`
4. Выполнить команду `docker-compose up -d --build`, после чего сервис поднимется на localhost:${APP_PORT}

Запуск проекта вне докера:
1. Настроить .env файл: DP_HOST установить на хост базы (локально - localhost)
2. Установить swaggo `go get github.com/swaggo/swag/cmd/swag`
3. Выполнить `swag init -g ./cmd/http/main.go`
4. Выполнить команду `go run cmd/http/main.go`, после чего сервис поднимется на localhost:${APP_PORT}

____
## Методы
____
**1. Пополнение баланса пользователя**

Для пополнения баланса пользователя в теле POST запроса по 
адресу `/api/account/balance/add` отправить JSON структуру
```josn
{
    account_id	integer
    amount	number
}
```
____
**2. Получение баланса пользователя**

Для получения баланса пользователя в теле POST запроса по
адресу `/api/account/balance` отправить JSON структуру
```josn
{
    account_id	integer
}
```
____
**3. Перевод средств от пользователя пользователю**

Для перевода средств от пользователя пользователю в теле POST запроса по
адресу `/api/account/transfer` отправить JSON структуру
```josn
{
    amount	number
    from_account_id	integer
    to_account_id	integer
}
```
____
**4. Резервирование средств**

Для резервирования средств в теле POST запроса по
адресу `/api/account/balance/reserve` отправить JSON структуру
```josn
{
    account_id	integer
    operation_id	integer
    service_id	integer
    total_cost	number
}
```
____
**5. Списание зарезервированных средств**

Для списания зарезервированных средств в теле POST запроса по
адресу `/api/operation/approve` отправить JSON структуру
```josn
{
    account_id	integer
    operation_id	integer
    service_id	integer
    total_cost	number
}
```
____
**6. Разрезервирование средств**

Для разрезервирования средств в теле POST запроса по
адресу `/api/account/balance/unreserve` отправить JSON структуру
```josn
{
    account_id	integer
    operation_id	integer
    service_id	integer
    total_cost	number
}
```
____
**7. Получение отчета по транзакциям за месяц с текущей даты**
Для получения отчета по транзакциям необходимо выполнить GET запрос по
адресу `/api/report/`

____
**8. Получение статистики пользователя**

Для получения отчета по транзакциям необходимо выполнить GET запрос по
адресу `http://localhost:8080/api/account/{account_id}/statistic?order={cost|date}&direction={1|0}&lpage={last_page_id}&npage={new_page_id}&operation={last_operation_id}`

В URL запроса содержатся следующие параметры:
1. `account_id` - ID аккаунта, по которому необходимо получить статистику
2. `order` - обязательный параметр, отвечающий за то, по какому критерию будут отсортированы 
транзакции. Может принимать параметры `cost` (по цене) и `date` (по дате)
3. `direction` - обязательный параметр, отвечающий за порядок сортировки. 
Может принимать значения `1` (по возрастанию) и `0` (по убыванию)
4. `lpage` - обязательный параметр, отвечающий за текущую просматриваемую страницу.
Может принимать не отрицательные значения
5. `npage` - обязательный параметр, отвечающий за страницу, на которую осуществляется переход.
Может принимать не отрицательные значения
6. `operation` - необязательный параметр, берущийся из ответа на предыдущий переход по страницам,
указывающий на ID последней выданной транзакции в текущем заданном порядке вывода. При
первом запросе (запросе первой страницы) остается пустым. Далее берется из
каждого следующего запроса

____
**9. Статические файлы**

Все сгенерированные отчеты csv располагаются по пути `/reports/{file_name}`


-----
## swagger-документация

swagger-документация располагается по адресу `/documentation/`

Чтобы сгенерировать ее на проекте необходимо выполнить команду `swag init -g ./cmd/http/main.go`

-----

# Важно:
* Таблицы создаются при старте приложения, также заполняются необходимые данные
(статусы заказов, аккаунт компании, примеры услуг)

## Возникшие вопросы и их решения:
* Не совсем понимал сути передачи такого кол-ва параметров в методе перевода средств на
счет компании, но использовал их в where sql запроса для "детального описания" 
желаемой транзакции в передаваемых данных, раз уж приходят и их нужно использовать, по идее))


## Детали реализации (в какой-то мере, интересные, по-моему):

* Выбор статистики у пользователя реализован через комбинацию кортежного сравнения
и limit offset, т.к. обычный limit offset работает относительно медленно, а кортежное 
сравнение не дает "прыгать" по страницам. 
* Dockerfile - двух-этапная сборка, чтобы итоговый образ занимал меньше места (
при одно этапной сборке около 200мб занимает, так 30мб)
* Все сгенерированные отчеты сохраняются на машинке в отдельной директории,
которую, при желании, можно "высунуть" из контейнера наружу. При этом эта папка
"раздается" статически и все отчеты можно достать в любой момент

## Ретроспектива:
* Лучше бы сделал тесты, вместо рутинной работы обработок ошибок в данных на входе
* Методы работы с базой, лучше было бы сделать, принимающими, через интерфейсовую обертку
"свою транзакцию", которая имела бы queryrow и exec, и через нее уже выполнялись
методы с базой, а снаружи комитились или ролбекались, чтобы была более гибкая работа с 
базой на транзакциях



## Что можно улучшить, при желании и наличии времени:
* Кешировать запросы ISExists в памяти или же в редисе (нужно с инвалидацией кеша
поковыряться, не знаю, как правильно в golang делать)
* Тесты, естественно
* Под вопросом кеширование статистики, ведь может получиться, что просто
будет забиваться оперативка/redis, если запрашивают реже, чем происходит
инвалидация кеша. 
* Некоторые sql запросы можно склеить в один при помощи сложных if в них и вложенности,
но стоит ли оно того, ведь читаемость умирает, а производительность решается кешом. 

## Вопросы, на которые хочу получить ответы, если будет фидбек (поделитесь знаниями пожалуйста))):
* Как лучше построить архитектуру проекта: расположить все интерфейсы в своем отдельном
пакете и там разбивать по смысловой нагрузке (условно, аккаунты к аккаунтам), или 
как тут, внутри функциональных частей (handler, service, db, ...) раскидывать + там
уже делить по смыслам?
* Лучше распределять роутеры внутри одного файла, или, как я, что-то типа дерева
строить и раскидывать по отдельным файлам функциональные блоки?
* Как сделать так, чтобы роутеры сами срезали обратный слеш в конце query? 
Чтобы `/router/` и `/router` было одно и тоже?
* Хорошо ли хранить отчеты на машинке? Или без разницы, просто зависит от бизнес задачи?
* Правильно ли в golang раскидывать методы большой структуры по отдельным файлам, 
или же принято тянуть один большой файл? Или просто избегают больших структур (в плане 
строк кода на ее методы + поля)?

